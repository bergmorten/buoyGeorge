// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: from_buoy/v1/from_buoy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Profile } from "../ad2cp/v1/ad2cp";
import { Recording } from "../ahrs/v1/ahrs";
import { Location } from "../gnss/v1/gnss";
import { Entry } from "../log/v1/log";
import { Manifest } from "../manifest/v1/manifest";
import { SelfTest } from "../self_test/v1/self_test";
import { Performance } from "../system/v1/system";
import { Profile as Profile1 } from "../wave/v1/wave";

export const protobufPackage = "from_buoy.v1";

/** Used if cloud should merge messages */
export interface MultiMessage {
  /** Message ID, increasing counter, used to identify the message */
  messageId: number;
  /** Total number of messages in this message */
  totalMessages: number;
  /** Sequence number of this message */
  sequenceNumber: number;
}

/** Records from onboard sensors */
export interface SensorRecord {
  /** AD2CP profiles */
  profiles: Profile[];
  /** Ahrs recordings */
  ahrs: Recording[];
  /** Wave profiles */
  waves: Profile1[];
  /** GNSS locations */
  locations: Location[];
}

/** Main message for data from the buoy */
export interface FromBuoy {
  /** For use in future updates */
  version?:
    | number
    | undefined;
  /** Message sent UTC Seconds since 2025-01-01T00:00:00Z */
  seconds2025?:
    | number
    | undefined;
  /** Multi-message information, used for e.g. SBD */
  multiMessage?:
    | MultiMessage
    | undefined;
  /** System performance */
  system: Performance[];
  /** Log messages */
  logs: Entry[];
  /** Self test report */
  selfTest?:
    | SelfTest
    | undefined;
  /** Manifest / System information */
  manifest?:
    | Manifest
    | undefined;
  /** Sensor record */
  sensorRecord?: SensorRecord | undefined;
}

function createBaseMultiMessage(): MultiMessage {
  return { messageId: 0, totalMessages: 0, sequenceNumber: 0 };
}

export const MultiMessage: MessageFns<MultiMessage> = {
  encode(message: MultiMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.messageId !== 0) {
      writer.uint32(8).uint32(message.messageId);
    }
    if (message.totalMessages !== 0) {
      writer.uint32(16).uint32(message.totalMessages);
    }
    if (message.sequenceNumber !== 0) {
      writer.uint32(24).uint32(message.sequenceNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.messageId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalMessages = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sequenceNumber = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiMessage {
    return {
      messageId: isSet(object.messageId) ? globalThis.Number(object.messageId) : 0,
      totalMessages: isSet(object.totalMessages) ? globalThis.Number(object.totalMessages) : 0,
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.Number(object.sequenceNumber) : 0,
    };
  },

  toJSON(message: MultiMessage): unknown {
    const obj: any = {};
    if (message.messageId !== 0) {
      obj.messageId = Math.round(message.messageId);
    }
    if (message.totalMessages !== 0) {
      obj.totalMessages = Math.round(message.totalMessages);
    }
    if (message.sequenceNumber !== 0) {
      obj.sequenceNumber = Math.round(message.sequenceNumber);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiMessage>, I>>(base?: I): MultiMessage {
    return MultiMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiMessage>, I>>(object: I): MultiMessage {
    const message = createBaseMultiMessage();
    message.messageId = object.messageId ?? 0;
    message.totalMessages = object.totalMessages ?? 0;
    message.sequenceNumber = object.sequenceNumber ?? 0;
    return message;
  },
};

function createBaseSensorRecord(): SensorRecord {
  return { profiles: [], ahrs: [], waves: [], locations: [] };
}

export const SensorRecord: MessageFns<SensorRecord> = {
  encode(message: SensorRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.profiles) {
      Profile.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.ahrs) {
      Recording.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.waves) {
      Profile1.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.locations) {
      Location.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SensorRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSensorRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.profiles.push(Profile.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ahrs.push(Recording.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.waves.push(Profile1.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.locations.push(Location.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SensorRecord {
    return {
      profiles: globalThis.Array.isArray(object?.profiles) ? object.profiles.map((e: any) => Profile.fromJSON(e)) : [],
      ahrs: globalThis.Array.isArray(object?.ahrs) ? object.ahrs.map((e: any) => Recording.fromJSON(e)) : [],
      waves: globalThis.Array.isArray(object?.waves) ? object.waves.map((e: any) => Profile1.fromJSON(e)) : [],
      locations: globalThis.Array.isArray(object?.locations)
        ? object.locations.map((e: any) => Location.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SensorRecord): unknown {
    const obj: any = {};
    if (message.profiles?.length) {
      obj.profiles = message.profiles.map((e) => Profile.toJSON(e));
    }
    if (message.ahrs?.length) {
      obj.ahrs = message.ahrs.map((e) => Recording.toJSON(e));
    }
    if (message.waves?.length) {
      obj.waves = message.waves.map((e) => Profile1.toJSON(e));
    }
    if (message.locations?.length) {
      obj.locations = message.locations.map((e) => Location.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SensorRecord>, I>>(base?: I): SensorRecord {
    return SensorRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SensorRecord>, I>>(object: I): SensorRecord {
    const message = createBaseSensorRecord();
    message.profiles = object.profiles?.map((e) => Profile.fromPartial(e)) || [];
    message.ahrs = object.ahrs?.map((e) => Recording.fromPartial(e)) || [];
    message.waves = object.waves?.map((e) => Profile1.fromPartial(e)) || [];
    message.locations = object.locations?.map((e) => Location.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFromBuoy(): FromBuoy {
  return {
    version: undefined,
    seconds2025: undefined,
    multiMessage: undefined,
    system: [],
    logs: [],
    selfTest: undefined,
    manifest: undefined,
    sensorRecord: undefined,
  };
}

export const FromBuoy: MessageFns<FromBuoy> = {
  encode(message: FromBuoy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== undefined) {
      writer.uint32(8).uint32(message.version);
    }
    if (message.seconds2025 !== undefined) {
      writer.uint32(16).uint32(message.seconds2025);
    }
    if (message.multiMessage !== undefined) {
      MultiMessage.encode(message.multiMessage, writer.uint32(26).fork()).join();
    }
    for (const v of message.system) {
      Performance.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.logs) {
      Entry.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.selfTest !== undefined) {
      SelfTest.encode(message.selfTest, writer.uint32(50).fork()).join();
    }
    if (message.manifest !== undefined) {
      Manifest.encode(message.manifest, writer.uint32(58).fork()).join();
    }
    if (message.sensorRecord !== undefined) {
      SensorRecord.encode(message.sensorRecord, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FromBuoy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFromBuoy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.seconds2025 = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.multiMessage = MultiMessage.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.system.push(Performance.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.logs.push(Entry.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.selfTest = SelfTest.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.manifest = Manifest.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.sensorRecord = SensorRecord.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FromBuoy {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : undefined,
      seconds2025: isSet(object.seconds2025) ? globalThis.Number(object.seconds2025) : undefined,
      multiMessage: isSet(object.multiMessage) ? MultiMessage.fromJSON(object.multiMessage) : undefined,
      system: globalThis.Array.isArray(object?.system) ? object.system.map((e: any) => Performance.fromJSON(e)) : [],
      logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e: any) => Entry.fromJSON(e)) : [],
      selfTest: isSet(object.selfTest) ? SelfTest.fromJSON(object.selfTest) : undefined,
      manifest: isSet(object.manifest) ? Manifest.fromJSON(object.manifest) : undefined,
      sensorRecord: isSet(object.sensorRecord) ? SensorRecord.fromJSON(object.sensorRecord) : undefined,
    };
  },

  toJSON(message: FromBuoy): unknown {
    const obj: any = {};
    if (message.version !== undefined) {
      obj.version = Math.round(message.version);
    }
    if (message.seconds2025 !== undefined) {
      obj.seconds2025 = Math.round(message.seconds2025);
    }
    if (message.multiMessage !== undefined) {
      obj.multiMessage = MultiMessage.toJSON(message.multiMessage);
    }
    if (message.system?.length) {
      obj.system = message.system.map((e) => Performance.toJSON(e));
    }
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => Entry.toJSON(e));
    }
    if (message.selfTest !== undefined) {
      obj.selfTest = SelfTest.toJSON(message.selfTest);
    }
    if (message.manifest !== undefined) {
      obj.manifest = Manifest.toJSON(message.manifest);
    }
    if (message.sensorRecord !== undefined) {
      obj.sensorRecord = SensorRecord.toJSON(message.sensorRecord);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FromBuoy>, I>>(base?: I): FromBuoy {
    return FromBuoy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FromBuoy>, I>>(object: I): FromBuoy {
    const message = createBaseFromBuoy();
    message.version = object.version ?? undefined;
    message.seconds2025 = object.seconds2025 ?? undefined;
    message.multiMessage = (object.multiMessage !== undefined && object.multiMessage !== null)
      ? MultiMessage.fromPartial(object.multiMessage)
      : undefined;
    message.system = object.system?.map((e) => Performance.fromPartial(e)) || [];
    message.logs = object.logs?.map((e) => Entry.fromPartial(e)) || [];
    message.selfTest = (object.selfTest !== undefined && object.selfTest !== null)
      ? SelfTest.fromPartial(object.selfTest)
      : undefined;
    message.manifest = (object.manifest !== undefined && object.manifest !== null)
      ? Manifest.fromPartial(object.manifest)
      : undefined;
    message.sensorRecord = (object.sensorRecord !== undefined && object.sensorRecord !== null)
      ? SensorRecord.fromPartial(object.sensorRecord)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
