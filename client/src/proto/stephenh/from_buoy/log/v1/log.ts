// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: from_buoy/log/v1/log.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "from_buoy.log.v1";

/** The level or importance of the log message */
export enum Level {
  /** LEVEL_UNSPECIFIED - Not specified log level */
  LEVEL_UNSPECIFIED = 0,
  /** LEVEL_DEBUG - Debug log level */
  LEVEL_DEBUG = 1,
  /** LEVEL_INFO - Informational log level */
  LEVEL_INFO = 2,
  /** LEVEL_WARNING - Warning log level */
  LEVEL_WARNING = 3,
  /** LEVEL_ERROR - Error log level */
  LEVEL_ERROR = 4,
  /** LEVEL_CRITICAL - Critical log level, a non-recoverable error */
  LEVEL_CRITICAL = 5,
  UNRECOGNIZED = -1,
}

export function levelFromJSON(object: any): Level {
  switch (object) {
    case 0:
    case "LEVEL_UNSPECIFIED":
      return Level.LEVEL_UNSPECIFIED;
    case 1:
    case "LEVEL_DEBUG":
      return Level.LEVEL_DEBUG;
    case 2:
    case "LEVEL_INFO":
      return Level.LEVEL_INFO;
    case 3:
    case "LEVEL_WARNING":
      return Level.LEVEL_WARNING;
    case 4:
    case "LEVEL_ERROR":
      return Level.LEVEL_ERROR;
    case 5:
    case "LEVEL_CRITICAL":
      return Level.LEVEL_CRITICAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Level.UNRECOGNIZED;
  }
}

export function levelToJSON(object: Level): string {
  switch (object) {
    case Level.LEVEL_UNSPECIFIED:
      return "LEVEL_UNSPECIFIED";
    case Level.LEVEL_DEBUG:
      return "LEVEL_DEBUG";
    case Level.LEVEL_INFO:
      return "LEVEL_INFO";
    case Level.LEVEL_WARNING:
      return "LEVEL_WARNING";
    case Level.LEVEL_ERROR:
      return "LEVEL_ERROR";
    case Level.LEVEL_CRITICAL:
      return "LEVEL_CRITICAL";
    case Level.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** In which part did error occur? */
export enum Subsystem {
  /** SUBSYSTEM_UNSPECIFIED - Unknown or not set */
  SUBSYSTEM_UNSPECIFIED = 0,
  /** SUBSYSTEM_CPU - Main CPU */
  SUBSYSTEM_CPU = 1,
  /** SUBSYSTEM_COMMS - Communications */
  SUBSYSTEM_COMMS = 2,
  /** SUBSYSTEM_AD2CP - AD2CP */
  SUBSYSTEM_AD2CP = 3,
  /** SUBSYSTEM_GNSS - GNSS */
  SUBSYSTEM_GNSS = 4,
  UNRECOGNIZED = -1,
}

export function subsystemFromJSON(object: any): Subsystem {
  switch (object) {
    case 0:
    case "SUBSYSTEM_UNSPECIFIED":
      return Subsystem.SUBSYSTEM_UNSPECIFIED;
    case 1:
    case "SUBSYSTEM_CPU":
      return Subsystem.SUBSYSTEM_CPU;
    case 2:
    case "SUBSYSTEM_COMMS":
      return Subsystem.SUBSYSTEM_COMMS;
    case 3:
    case "SUBSYSTEM_AD2CP":
      return Subsystem.SUBSYSTEM_AD2CP;
    case 4:
    case "SUBSYSTEM_GNSS":
      return Subsystem.SUBSYSTEM_GNSS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Subsystem.UNRECOGNIZED;
  }
}

export function subsystemToJSON(object: Subsystem): string {
  switch (object) {
    case Subsystem.SUBSYSTEM_UNSPECIFIED:
      return "SUBSYSTEM_UNSPECIFIED";
    case Subsystem.SUBSYSTEM_CPU:
      return "SUBSYSTEM_CPU";
    case Subsystem.SUBSYSTEM_COMMS:
      return "SUBSYSTEM_COMMS";
    case Subsystem.SUBSYSTEM_AD2CP:
      return "SUBSYSTEM_AD2CP";
    case Subsystem.SUBSYSTEM_GNSS:
      return "SUBSYSTEM_GNSS";
    case Subsystem.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Detailed log information where in code */
export interface Detailed {
  /** Detailed log message */
  filename?:
    | string
    | undefined;
  /** Function name */
  function?:
    | string
    | undefined;
  /** Line number */
  line?:
    | number
    | undefined;
  /** Column number */
  column?: number | undefined;
}

/** This is the log message */
export interface Entry {
  /** Recorded at UTC Seconds since 2025-01-01T00:00:00Z */
  seconds2025?:
    | number
    | undefined;
  /** Log level */
  level?:
    | Level
    | undefined;
  /** Subsystem that generated the log */
  subsystem?:
    | Subsystem
    | undefined;
  /** Log message */
  message?:
    | string
    | undefined;
  /** Detailed log information */
  detailed?: Detailed | undefined;
}

function createBaseDetailed(): Detailed {
  return { filename: undefined, function: undefined, line: undefined, column: undefined };
}

export const Detailed: MessageFns<Detailed> = {
  encode(message: Detailed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filename !== undefined) {
      writer.uint32(10).string(message.filename);
    }
    if (message.function !== undefined) {
      writer.uint32(18).string(message.function);
    }
    if (message.line !== undefined) {
      writer.uint32(24).uint32(message.line);
    }
    if (message.column !== undefined) {
      writer.uint32(32).uint32(message.column);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Detailed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetailed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filename = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.function = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.line = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.column = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Detailed {
    return {
      filename: isSet(object.filename) ? globalThis.String(object.filename) : undefined,
      function: isSet(object.function) ? globalThis.String(object.function) : undefined,
      line: isSet(object.line) ? globalThis.Number(object.line) : undefined,
      column: isSet(object.column) ? globalThis.Number(object.column) : undefined,
    };
  },

  toJSON(message: Detailed): unknown {
    const obj: any = {};
    if (message.filename !== undefined) {
      obj.filename = message.filename;
    }
    if (message.function !== undefined) {
      obj.function = message.function;
    }
    if (message.line !== undefined) {
      obj.line = Math.round(message.line);
    }
    if (message.column !== undefined) {
      obj.column = Math.round(message.column);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Detailed>, I>>(base?: I): Detailed {
    return Detailed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Detailed>, I>>(object: I): Detailed {
    const message = createBaseDetailed();
    message.filename = object.filename ?? undefined;
    message.function = object.function ?? undefined;
    message.line = object.line ?? undefined;
    message.column = object.column ?? undefined;
    return message;
  },
};

function createBaseEntry(): Entry {
  return { seconds2025: undefined, level: undefined, subsystem: undefined, message: undefined, detailed: undefined };
}

export const Entry: MessageFns<Entry> = {
  encode(message: Entry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.seconds2025 !== undefined) {
      writer.uint32(8).uint32(message.seconds2025);
    }
    if (message.level !== undefined) {
      writer.uint32(16).int32(message.level);
    }
    if (message.subsystem !== undefined) {
      writer.uint32(24).int32(message.subsystem);
    }
    if (message.message !== undefined) {
      writer.uint32(34).string(message.message);
    }
    if (message.detailed !== undefined) {
      Detailed.encode(message.detailed, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Entry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.seconds2025 = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.level = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.subsystem = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.detailed = Detailed.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Entry {
    return {
      seconds2025: isSet(object.seconds2025) ? globalThis.Number(object.seconds2025) : undefined,
      level: isSet(object.level) ? levelFromJSON(object.level) : undefined,
      subsystem: isSet(object.subsystem) ? subsystemFromJSON(object.subsystem) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
      detailed: isSet(object.detailed) ? Detailed.fromJSON(object.detailed) : undefined,
    };
  },

  toJSON(message: Entry): unknown {
    const obj: any = {};
    if (message.seconds2025 !== undefined) {
      obj.seconds2025 = Math.round(message.seconds2025);
    }
    if (message.level !== undefined) {
      obj.level = levelToJSON(message.level);
    }
    if (message.subsystem !== undefined) {
      obj.subsystem = subsystemToJSON(message.subsystem);
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    if (message.detailed !== undefined) {
      obj.detailed = Detailed.toJSON(message.detailed);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Entry>, I>>(base?: I): Entry {
    return Entry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Entry>, I>>(object: I): Entry {
    const message = createBaseEntry();
    message.seconds2025 = object.seconds2025 ?? undefined;
    message.level = object.level ?? undefined;
    message.subsystem = object.subsystem ?? undefined;
    message.message = object.message ?? undefined;
    message.detailed = (object.detailed !== undefined && object.detailed !== null)
      ? Detailed.fromPartial(object.detailed)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
